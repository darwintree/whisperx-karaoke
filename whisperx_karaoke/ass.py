def formatted_word_with_length(text: str, milliseconds: int):
    return "{\\kf" + str(milliseconds) + "}" + text

def insert(s: str, index: int, substring: str):
    return s[:index] + substring + s[index:]

def segment_to_ass_line(segment, next_segment=None):
    words = segment["words"]
    # next_segment_start = segment["end"]
    # if next_segment != None:
    #     next_segment_start = next_segment["start"]

    line_prefix = (
        f"Dialogue: 0,{segment['start']:.3f},{segment['end']:.3f},orig,,0,0,0,,"
    )
    last_word_end: float = segment["start"]
    # append word to the line
    last_index = 0
    # [{"index": int, "duration": float}]
    insert_duractions: list = []
    line_lyric: str = segment["text"]
    for i in range(len(words)):
        word = words[i]
        if i == len(words) - 1:
            # last word
            word_duration = segment["end"] - last_word_end
            place_to_insert_duration = line_lyric.index(word["word"], last_index)
            insert_duractions.append(
                {"index": place_to_insert_duration, "duration": word_duration}
            )
            # duration_mark = "{\\kf" + str(int(100 * word_duration)) + "}"
            # line_lyric = insert(line_lyric, place_to_insert_duration, duration_mark)
            continue
        if not word.get("end"):
            # update last_index pointer
            if word_index := line_lyric.index(word["word"], last_index) != 0:
                last_index = word_index
            continue
        word_duration = word.get("end") - last_word_end
        place_to_insert_duration = line_lyric.index(word["word"], last_index)
        insert_duractions.append({
            "index": place_to_insert_duration,
            "duration": word_duration,
        })
        # duration_mark = "{\\kf" + str(int(100 * word_duration)) + "}"
        # line_lyric = insert(line_lyric, place_to_insert_duration, duration_mark)
        # last_index = place_to_insert_duration + len(duration_mark)
        last_index = place_to_insert_duration
        last_word_end = word.get("end")
    # insert from back to front
    for i in range(len(insert_duractions)):
        insert_duration = insert_duractions[len(insert_duractions) - 1 - i]
        duration_mark = "{\\kf" + str(int(100 * insert_duration["duration"])) + "}"
        line_lyric = insert(line_lyric, insert_duration["index"], duration_mark)

    return line_prefix + line_lyric


def segments_to_ass_text(segments):
    ass_text = """[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
ScriptType: v4.00+
Timer: 100.0000

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: roma,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: orig,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    for i in range(len(segments)):
        segment = segments[i]
        next_segment = None if (i + 1) == len(segments) else segments[i + 1]
        ass_text += segment_to_ass_line(segment, next_segment)
        ass_text += "\n"
    return ass_text
